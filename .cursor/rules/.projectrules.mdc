# Cursor Project Rules for Rainfall Weather Analytics App

## Project Overview

This is a SvelteKit-based weather analytics dashboard that provides comprehensive rainfall, temperature, wind, and solar data analysis for UK locations. The application uses TypeScript, Tailwind CSS, Chart.js, and Leaflet for mapping.

## Technology Stack

- **Framework**: SvelteKit with TypeScript
- **Styling**: Tailwind CSS v4 with custom typography plugin
- **Charts**: Chart.js with date-fns adapter
- **Maps**: Leaflet with svelte-leafletjs
- **Build Tool**: Vite
- **Testing**: Playwright for E2E tests
- **Code Quality**: ESLint, Prettier, TypeScript

## Code Style & Formatting

### General Guidelines

- Use British English in comments and documentation but keep code identifiers in US English
- Use tabs for indentation (as per .prettierrc config)
- Single quotes for strings
- No trailing commas
- Max line width: 100 characters
- Always use TypeScript - no plain JavaScript files in src/

### File Naming Conventions

- Components: PascalCase.svelte (e.g., `RainfallChart.svelte`)
- Utilities: camelCase.ts (e.g., `dataProcessing.ts`)
- Types: camelCase.ts (use `types.ts` for shared types)
- Services: camelCase.ts (e.g., `weatherApi.ts`)
- Routes: kebab-case directories with +page.svelte files

### Component Structure

```svelte
<script lang="ts">
	// 1. Imports (external libraries first, then internal)
	import { onMount } from 'svelte';
	import type { ComponentType } from '../types.js';

	// 2. Props with explicit types
	export let data: ComponentType;
	export let loading = false;

	// 3. Local variables
	let localState = '';

	// 4. Reactive statements
	$: processedData = data ? processData(data) : [];

	// 5. Functions
	function handleClick() {
		// implementation
	}

	// 6. Lifecycle
	onMount(() => {
		// initialization
	});
</script>

<!-- Template with proper indentation -->
<div class="component-wrapper">
	{#if loading}
		<!-- Loading state -->
	{:else}
		<!-- Main content -->
	{/if}
</div>

<!-- Styles (prefer Tailwind classes) -->
<style>
	/* Only custom CSS when Tailwind isn't sufficient */
</style>
```

## TypeScript Guidelines

### Interface Definitions

- Define all interfaces in `src/lib/types.ts`
- Use PascalCase for interface names
- Add JSDoc comments for complex interfaces
- Use optional properties (`?`) appropriately
- Prefer interfaces over types for object shapes

### Type Safety

- Always export types/interfaces used across files
- Use `import type` for type-only imports
- Avoid `any` - use proper typing or `unknown`
- Use generic types for reusable components
- Prefer union types over enums for string literals

### Example Type Usage

```typescript
// Good
import type { RainfallData, Location } from '../types.js';

export interface ChartProps {
	data: RainfallData[];
	title: string;
	height?: number;
}

// Avoid
export let data: any;
```

## Component Architecture

### Component Organization

```
src/lib/components/
├── charts/              # Chart components (RainfallChart.svelte, etc.)
├── panels/             # Dashboard panels
├── ui/                 # Reusable UI components
└── layout/             # Layout components
```

### Component Props

- Use explicit prop types with TypeScript
- Provide sensible defaults for optional props
- Use reactive statements for derived values
- Keep components focused on single responsibility

### State Management

- Use component-level state for UI-specific data
- Pass data down through props rather than global stores
- Use reactive statements for computed values
- Keep loading states at the appropriate component level

## Data Processing

### API Integration

- All API calls should go through service files in `src/lib/services/`
- Implement proper error handling with try/catch
- Use caching strategies for expensive API calls
- Type all API responses with proper interfaces

### Data Transformation

- Keep data processing functions in `src/lib/utils/dataProcessing.ts`
- Pure functions only - no side effects
- Use TypeScript for input/output type safety
- Handle edge cases (empty arrays, null values)

### Example Service Pattern

```typescript
export async function getWeatherData(lat: number, lon: number): Promise<WeatherData[]> {
	try {
		const response = await fetch(buildApiUrl(lat, lon));
		if (!response.ok) {
			throw new Error(`API Error: ${response.status}`);
		}
		const data = await response.json();
		return transformApiResponse(data);
	} catch (error) {
		console.error('Weather API error:', error);
		throw new Error('Failed to fetch weather data');
	}
}
```

## Styling Guidelines

### Tailwind CSS Usage

- Use Tailwind utility classes primarily
- Create custom components only when needed
- Use responsive design patterns (`sm:`, `md:`, `lg:`)
- Maintain consistent spacing scale
- Use semantic color names

### Responsive Design

- Mobile-first approach
- Grid layouts for dashboard components
- Flexible chart containers
- Appropriate text sizing across devices

### Color Scheme

- Primary: Blue tones for main actions
- Secondary: Gray scale for text and backgrounds
- Weather-specific colors:
  - Rain/Precipitation: Blue variants
  - Temperature: Red/orange variants
  - Wind: Cyan variants
  - Solar: Yellow/orange variants

## Performance Guidelines

### Optimization Strategies

- Lazy load heavy components
- Implement proper loading states
- Cache API responses appropriately
- Use Chart.js efficiently with proper data structures
- Minimize re-renders with proper reactive statements

### Bundle Optimization

- Import only what you need from libraries
- Use dynamic imports for large components
- Optimize images and assets
- Minimize CSS bundle size

## Error Handling

### Error Boundaries

- Implement proper error handling in components
- Show user-friendly error messages
- Log errors appropriately for debugging
- Provide fallback UI for failed states

### API Error Handling

```typescript
// Good error handling pattern
try {
	const data = await apiCall();
	return data;
} catch (error) {
	console.error('API Error:', error);
	throw new Error('User-friendly message');
}
```

## Testing Approach

### E2E Testing with Playwright

- Test critical user journeys
- Test across different browsers
- Include mobile viewport testing
- Test with real API data when possible

### Component Testing

- Test component props and events
- Test loading and error states
- Test responsive behaviour
- Test accessibility features

## Accessibility Requirements

### ARIA Guidelines

- Proper heading hierarchy (h1, h2, h3)
- Alt text for all images and charts
- Keyboard navigation support
- Screen reader friendly content
- Focus management

### Chart Accessibility

- Provide data tables as alternatives
- Use sufficient color contrast
- Include text descriptions of chart data
- Keyboard accessible chart interactions

## Security Considerations

### API Security

- Validate all external data
- Sanitize user inputs (postcodes)
- Implement rate limiting awareness
- Use HTTPS for all API calls
- Never expose API keys in client code

### Data Privacy

- Minimal data collection
- Clear data usage policies
- Cache management for sensitive data
- Secure local storage usage

## Build & Deployment

### Development Workflow

- Use `npm run dev` for development
- Run `npm run check` before commits
- Use `npm run format` for code formatting
- Run `npm run lint` for code quality
- Test with `npm run test:e2e`

### Production Build

- Static site generation with SvelteKit
- Optimize for CDN delivery
- Compress assets appropriately
- Include proper meta tags for SEO

## Git Workflow

### Commit Messages

- Use conventional commits format
- Include issue numbers when applicable
- Keep commits focused and atomic
- Write descriptive commit messages

### Branch Naming

- `feature/feature-name` for new features
- `fix/bug-description` for bug fixes
- `refactor/component-name` for refactoring
- `docs/update-description` for documentation

## Documentation Standards

### Code Documentation

- JSDoc comments for complex functions
- README updates for new features
- Component prop documentation
- API service documentation

### User Documentation

- Clear component usage examples
- Setup and installation instructions
- Configuration guidelines
- Troubleshooting guides

## Common Patterns to Follow

### Loading States

```svelte
{#if loading}
	<div class="animate-pulse">Loading...</div>
{:else if error}
	<div class="text-red-600">Error: {error}</div>
{:else}
	<!-- Content -->
{/if}
```

### Chart Components

- Always include loading states
- Provide fallback for no data
- Use consistent height props
- Include proper TypeScript typing
- Handle responsive design

### Data Processing

- Pure functions in utils/
- Proper error handling
- TypeScript interfaces for all data
- Immutable data transformations

## Dependencies Management

### Adding New Dependencies

- Justify new dependencies
- Prefer smaller, focused libraries
- Check TypeScript support
- Consider bundle size impact
- Update package.json appropriately

### Version Management

- Keep dependencies updated
- Test thoroughly after updates
- Use exact versions for critical deps
- Document breaking changes

Remember: This is a weather analytics application focused on providing accurate, accessible data visualisation for UK weather patterns. Prioritise data accuracy, performance, and user experience in all development decisions.
